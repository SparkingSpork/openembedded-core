diff -urN a/include/applets.src.h b/include/applets.src.h
--- a/include/applets.src.h	2012-07-02 09:08:25.000000000 -0500
+++ b/include/applets.src.h	2013-07-01 12:04:46.948822905 -0500
@@ -382,7 +382,7 @@
 IF_UDHCPC(APPLET(udhcpc, BB_DIR_SBIN, BB_SUID_DROP))
 IF_UDHCPD(APPLET(udhcpd, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_UDPSVD(APPLET_ODDNAME(udpsvd, tcpudpsvd, BB_DIR_USR_BIN, BB_SUID_DROP, udpsvd))
-IF_UMOUNT(APPLET(umount, BB_DIR_BIN, BB_SUID_DROP))
+IF_UMOUNT(APPLET(umount, BB_DIR_BIN, IF_DESKTOP(BB_SUID_REQUIRE) IF_NOT_DESKTOP(BB_SUID_DROP)))
 IF_UNAME(APPLET(uname, BB_DIR_BIN, BB_SUID_DROP))
 IF_UNCOMPRESS(APPLET(uncompress, BB_DIR_BIN, BB_SUID_DROP))
 IF_UNEXPAND(APPLET_ODDNAME(unexpand, expand, BB_DIR_USR_BIN, BB_SUID_DROP, unexpand))
diff -urN a/util-linux/umount.c b/util-linux/umount.c
--- a/util-linux/umount.c	2012-06-26 08:35:45.000000000 -0500
+++ b/util-linux/umount.c	2013-07-01 12:15:19.277743964 -0500
@@ -32,6 +32,10 @@
 #include <sys/mount.h>
 #include "libbb.h"
 
+#ifndef MS_SILENT
+# define MS_SILENT      (1 << 15)
+#endif
+
 #if defined(__dietlibc__)
 // TODO: This does not belong here.
 /* 16.12.2006, Sampo Kellomaki (sampo@iki.fi)
@@ -61,11 +65,117 @@
 #define OPT_REMOUNT             (1 << 5)
 #define OPT_ALL                 (ENABLE_FEATURE_UMOUNT_ALL ? (1 << 6) : 0)
 
+#ifdef ENABLE_DESKTOP
+
+#define GETMNTENT_BUFSIZE COMMON_BUFSIZE
+#define getmntent_buf     (bb_common_bufsiz1)
+
+// Not real flags, but we want to be able to check for this.
+enum {
+	MOUNT_USERS  = (1 << 28),
+};
+
+// Standard mount options (from -o options or --options),
+// with corresponding flags
+static const int32_t mount_options[] = {
+	/* "users" */ MOUNT_USERS,
+};
+
+// Only claim to support users (not user) since we don't check which user
+// mounted in the first place
+static const char mount_option_str[] =
+	"users\0"
+;
+// Use the mount_options list to parse options into flags.
+// Also update list of unrecognized options if unrecognized != NULL
+static long parse_mount_options(char *options)
+{
+	long flags = MS_SILENT;
+
+	// Loop through options
+	for (;;) {
+		unsigned i;
+		char *comma = strchr(options, ',');
+		const char *option_str = mount_option_str;
+
+		if (comma) *comma = '\0';
+
+// FIXME: use hasmntopt()
+		// Find this option in mount_options
+		for (i = 0; i < ARRAY_SIZE(mount_options); i++) {
+			if (strcasecmp(option_str, options) == 0) {
+				long fl = mount_options[i];
+				if (fl < 0)
+					flags &= fl;
+				else
+					flags |= fl;
+				goto found;
+			}
+			option_str += strlen(option_str) + 1;
+		}
+ found:
+		if (!comma)
+			break;
+		// Advance to next option
+		*comma = ',';
+		options = ++comma;
+	}
+
+	return flags;
+}
+
+static int find_fstab_mntent(const char *dir, struct mntent **ent)
+{
+	struct mntent mtpair[2], *mtcur = mtpair;
+	FILE *fstab;
+
+	fstab = setmntent("/etc/fstab", "r");
+	if (!fstab)
+		bb_perror_msg_and_die("can't read '/etc/fstab'");
+
+	// Loop through entries until we find what we're looking for
+	memset(mtpair, 0, sizeof(mtpair));
+	for (;;) {
+		struct mntent *mtother = (mtcur==mtpair ? mtpair+1 : mtpair);
+
+		// Get next fstab entry
+		if (!getmntent_r(fstab, mtcur, getmntent_buf
+					+ (mtcur==mtpair ? GETMNTENT_BUFSIZE/2 : 0),
+				GETMNTENT_BUFSIZE/2)
+		) { // End of fstab/mtab is reached
+			mtcur = mtother; // the thing we found last time
+			break;
+		}
+
+		// If we're trying to mount something specific and this isn't it,
+		// skip it.  Note we must match the exact text in fstab (ala
+		// "proc") or a full path from root
+
+		// Is this what we're looking for?
+		if (strcmp(dir, mtcur->mnt_fsname) != 0
+		 && strcmp(dir, mtcur->mnt_dir) != 0
+		) {
+			continue; // no
+		}
+
+		// Remember this entry.  Something later may have
+		// overmounted it, and we want the _last_ match.
+		mtcur = mtother;
+	}
+	if (!mtcur->mnt_fsname)
+		return 1;
+
+	*ent = mtcur;
+	return 0;
+}
+#endif /* ENABLE_DESKTOP */
+
 int umount_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int umount_main(int argc UNUSED_PARAM, char **argv)
 {
 	int doForce;
 	struct mntent me;
+	IF_DESKTOP(struct mntent *fme;)
 	FILE *fp;
 	char *fstype = NULL;
 	int status = EXIT_SUCCESS;
@@ -75,6 +185,9 @@
 		char *device;
 		struct mtab_list *next;
 	} *mtl, *m;
+	IF_NOT_DESKTOP(const int nonroot = 0;)
+
+	IF_DESKTOP(int nonroot = ) sanitize_env_if_suid();
 
 	opt = getopt32(argv, OPTION_STRING, &fstype);
 	//argc -= optind;
@@ -118,6 +231,9 @@
 		m = NULL;
 	}
 
+	if (nonroot && (opt & OPT_ALL)) // Non-root users cannot umount all
+		bb_error_msg_and_die(bb_msg_you_must_be_root);
+
 	// Loop through everything we're supposed to umount, and do so.
 	for (;;) {
 		int curstat;
@@ -147,6 +263,16 @@
 		// umount the directory even if we were given the block device.
 		if (m) zapit = m->dir;
 
+#ifdef ENABLE_DESKTOP
+		if (nonroot) {
+			if (find_fstab_mntent(zapit, &fme))
+				bb_error_msg_and_die(bb_msg_you_must_be_root);
+
+			if (!(parse_mount_options(fme->mnt_opts) & MOUNT_USERS))
+				bb_error_msg_and_die(bb_msg_you_must_be_root);
+		}
+#endif
+
 		// Let's ask the thing nicely to unmount.
 		curstat = umount(zapit);
 
